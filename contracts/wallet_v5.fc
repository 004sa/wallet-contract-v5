#pragma version =0.4.4;

#include "imports/stdlib.fc";

const int error::invalid_c5_action = 37;
const int error::extension_wrong_workchain = 45;
const int error::add_extension_error = 39;
const int error::remove_extension_error = 40;
const int error::disable_signature_when_extensions_is_empty = 42;
const int error::this_signature_mode_already_set = 43;
const int error::remove_last_extension_when_signature_disabled = 44;
const int error::unspported_action = 41;
const int error::signature_disabled = 32;
const int error::invalid_signature = 35;
const int error::invalid_seqno = 33;
const int error::invalid_wallet_id = 34;
const int error::expired = 36;
const int error::invalid_message_type = 47;

const int size::bool = 1;
const int size::seqno = 32;
const int size::wallet_id = 80;
const int size::public_key = 256;
const int size::valid_until = 32;
const int size::message_flags = 4;
const int size::signature = 512;
const int size::message_type_prefix = 32;
const int size::address_hash_size = 256;

const int prefix::signed_external = 0x7369676E;
const int prefix::signed_internal = 0x73696E74;

;;; performs a RET, but only if integer f is non-zero. If f is a NaN, throws an integer overflow exception.
() return_if(int f) impure asm "IFRET";
;;; performs a RET, but only if integer f is zero
() return_unless(int f) impure asm "IFNOTRET";

(slice, int) check_and_remove_extension_action_prefix(slice body) impure asm "x{6578746E} SDBEGINSQ";

(slice, int) check_and_remove_add_extension_prefix(slice body) impure asm "x{1c40db9f} SDBEGINSQ";
(slice, int) check_and_remove_remove_extension_prefix(slice body) impure asm "x{5eaef4a4} SDBEGINSQ";
(slice, int) check_and_remove_set_signature_allowed_prefix(slice body) impure asm "x{20cbb95a} SDBEGINSQ";

;;; returns the number of trailing zeroes in slice s.
int count_trailing_zeroes(slice s) asm "SDCNTTRAIL0";
;;; returns the number of trailing ones in slice s.
int count_trailing_ones(slice s) asm "SDCNTTRAIL1";

;;; returns the last 0 ≤ l ≤ 1023 bits of s.
slice get_last_bits(slice s, int l) asm "SDCUTLAST";
;;; returns all but the last 0 ≤ l ≤ 1023 bits of s.
slice remove_last_bits(slice s, int l) asm "SDSKIPLAST";


(slice, int) begin_parse_raw(cell c) asm "XCTOS";

;; `action_send_msg` has 0x0ec3c86d prefix
;; https://github.com/ton-blockchain/ton/blob/5c392e0f2d946877bb79a09ed35068f7b0bd333a/crypto/block/block.tlb#L380
slice enforce_and_remove_action_send_msg_prefix(slice body) impure asm "x{0ec3c86d} SDBEGINS";

;; Put raw list of OutActions to C5 register.
;; OutList TLB-schema - https://github.com/ton-blockchain/ton/blob/5c392e0f2d946877bb79a09ed35068f7b0bd333a/crypto/block/block.tlb#L378
;; C5 register - https://docs.ton.org/tvm.pdf, page 11
() set_c5_actions(cell action_list) impure asm "c5 POP";

cell verify_c5_actions(cell c5, int is_external) inline {
  (slice cs, _) = c5.begin_parse_raw();
  if (cs.slice_empty?()) {
    return c5;
  }

  do {
    ;; only `action_send_msg` is allowed, `action_set_code` or `action_reserve_currency` are not
    cs = cs.enforce_and_remove_action_send_msg_prefix();

    ;; action_send_msg#0ec3c86d mode:(## 8) out_msg:^(MessageRelaxed Any) = OutAction;
    ;; https://github.com/ton-blockchain/ton/blob/5c392e0f2d946877bb79a09ed35068f7b0bd333a/crypto/block/block.tlb#L380
    ;; enforce that send_mode has +2 bit (ignore errors) set for external message. For that load 7 bits and make sure that they end with 1
    throw_if(error::invalid_c5_action, is_external & (count_trailing_zeroes(cs.preload_bits(7)) > 0));

    (cs, _) = cs.preload_ref().begin_parse_raw();
  } until (cs.slice_empty?());

  return c5;
}

() process_actions(slice cs, int is_external) impure inline_ref {
  ;; Loop extended actions until we reach standard actions
  while (cs~load_int(1)) {
    int is_add_extension = cs~check_and_remove_add_extension_prefix();
    int is_remove_extension = is_add_extension ? 0 : cs~check_and_remove_remove_extension_prefix();
    ;; Add/remove extensions
    if (is_add_extension | is_remove_extension) {
      (int address_wc, int address_hash) = parse_std_addr(cs~load_msg_addr());
      (int my_address_wc, _) = parse_std_addr(my_address());

      throw_unless(error::extension_wrong_workchain, my_address_wc == address_wc);

      slice data_slice = get_data().begin_parse();
      slice data_slice_before_extensions = data_slice~load_bits(size::bool + size::seqno + size::wallet_id + size::public_key);
      cell extensions = data_slice.preload_dict();

      ;; Add extension
      if (is_add_extension) {
        (extensions, int is_success) = extensions.udict_add_builder?(size::address_hash_size, address_hash, begin_cell().store_int(-1, 1));
        throw_unless( error::add_extension_error, is_success);
      } else { ;; Remove extension
        (extensions, int is_success) = extensions.udict_delete?(size::address_hash_size, address_hash);
        throw_unless(error::remove_extension_error, is_success);
        int is_signature_allowed = data_slice_before_extensions.preload_int(size::bool);
        throw_if(error::remove_last_extension_when_signature_disabled, null?(extensions) & (~ is_signature_allowed));
      }

      set_data(begin_cell()
              .store_slice(data_slice_before_extensions)
              .store_dict(extensions)
              .end_cell());

    } elseif (cs~check_and_remove_set_signature_allowed_prefix()) {
      int allow_signature = cs~load_int(1);
      slice data_slice = get_data().begin_parse();
      int is_signature_allowed = data_slice~load_int(size::bool);
      throw_if(error::this_signature_mode_already_set, is_signature_allowed == allow_signature);
      is_signature_allowed = allow_signature;

      slice data_tail = data_slice; ;; seqno, wallet_id, public_key, extensions
      ifnot (allow_signature) { ;; disallow
        int is_extensions_not_empty = data_slice.skip_bits(size::seqno + size::wallet_id + size::public_key).preload_int(1);
        throw_unless(error::disable_signature_when_extensions_is_empty, is_extensions_not_empty);
      }

      set_data(begin_cell()
        .store_int(is_signature_allowed, size::bool)
        .store_slice(data_tail) ;; seqno, wallet_id, public_key, extensions
        .end_cell());
    } else {
      throw(error::unspported_action);
    }
    cs = cs.preload_ref().begin_parse();
  }
  ;; Simply set the C5 register with all pre-computed actions after verification:
  set_c5_actions(cs.preload_ref().verify_c5_actions(is_external));
}

;; ------------------------------------------------------------------------------------------------

() process_signed_request(slice in_msg_body, int is_external) impure inline {
  slice signature = in_msg_body.get_last_bits(size::signature);
  slice signed_slice = in_msg_body.remove_last_bits(size::signature);

  slice cs = signed_slice.skip_bits(size::message_type_prefix); ;; skip signed_internal or signed_external prefix
  (int wallet_id, int valid_until, int seqno) = (cs~load_uint(size::wallet_id), cs~load_uint(size::valid_until), cs~load_uint(size::seqno));

  slice data_slice = get_data().begin_parse();
  int is_signature_allowed = data_slice~load_int(size::bool);
  int stored_seqno = data_slice~load_uint(size::seqno);
  slice data_tail = data_slice; ;; wallet_id, public_key, extensions
  int stored_wallet_id = data_slice~load_uint(size::wallet_id);
  int public_key = data_slice.preload_uint(size::public_key);

  int is_signature_valid = check_signature(slice_hash(signed_slice), signature, public_key);
  ifnot (is_signature_valid) {
    if (is_external) {
      throw(error::invalid_signature);
    } else {
      return ();
    }
  }
  throw_unless(error::signature_disabled, is_signature_allowed);
  throw_unless(error::invalid_seqno, seqno == stored_seqno);
  throw_unless(error::invalid_wallet_id, wallet_id == stored_wallet_id);
  throw_if(error::expired, valid_until <= now());

  if (is_external) {
    accept_message();
  }

  ;; Store and commit the seqno increment to prevent replays even if the subsequent requests fail.
  stored_seqno = stored_seqno + 1;
  set_data(begin_cell()
    .store_int(true, size::bool) ;; is_signature_allowed
    .store_uint(stored_seqno, size::seqno)
    .store_slice(data_tail) ;; wallet_id, public_key, extensions
    .end_cell());

  commit();

  process_actions(cs, is_external);
}

() recv_external(slice in_msg_body) impure inline {
  throw_unless(error::invalid_message_type, in_msg_body.preload_uint(size::message_type_prefix) == prefix::signed_external);
  process_signed_request(in_msg_body, true);
}

;; ------------------------------------------------------------------------------------------------

() recv_internal(cell in_msg_full, slice in_msg_body) impure inline {
  return_if(in_msg_body.slice_refs_empty?()); ;; message with actions always have a ref

  slice in_msg_full_slice = in_msg_full.begin_parse();
  slice message_flags_slice = in_msg_full_slice~load_bits(size::message_flags); ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  ;; skip bounced messages - if bounced flag (last bit) is set amount of trailing ones will be non-zero, else it will be zero.
  return_if(count_trailing_ones(message_flags_slice) > 0);

  if (in_msg_body~check_and_remove_extension_action_prefix()) {

    ;; Authenticate extension by its address.
    (int sender_address_wc, int sender_address_hash) = parse_std_addr(in_msg_full_slice~load_msg_addr());
    (int my_address_wc, _) = parse_std_addr(my_address());

    return_unless(my_address_wc == sender_address_wc);

    cell extensions = get_data().begin_parse()
      .skip_bits(size::bool + size::seqno + size::wallet_id + size::public_key)
      .preload_dict();

    ;; Note that some random contract may have deposited funds with this prefix,
    ;; so we accept the funds silently instead of throwing an error (wallet v4 does the same).
    (_, int extension_found) = extensions.udict_get?(size::address_hash_size, sender_address_hash);
    return_unless(extension_found);

    process_actions(in_msg_body, false);
    return ();

  }

  return_unless(in_msg_body.preload_uint(size::message_type_prefix) == prefix::signed_internal);
  ;; Additional check to make sure that there are enough bits for reading (+1 for actual actions flag)
  return_if(in_msg_body.slice_bits() < size::message_type_prefix + size::wallet_id + size::valid_until + size::seqno + 1 + size::signature);
  process_signed_request(in_msg_body, false);
}

;; ------------------------------------------------------------------------------------------------
;; Get methods

int get_is_signature_auth_allowed() method_id {
  return get_data().begin_parse()
    .preload_int(size::bool);
}

int seqno() method_id {
  return get_data().begin_parse()
    .skip_bits(size::bool)
    .preload_uint(size::seqno);
}

int get_wallet_id() method_id {
  return get_data().begin_parse()
    .skip_bits(size::bool + size::seqno)
    .preload_uint(size::wallet_id);
}

int get_public_key() method_id {
  return get_data().begin_parse()
    .skip_bits(size::bool + size::seqno + size::wallet_id)
    .preload_uint(size::public_key);
}

;; Returns raw dictionary (or null if empty) where keys are address hashes. Workchains of extensions are same with wallet smart contract workchain
cell get_extensions() method_id {
  return get_data().begin_parse()
    .skip_bits(size::bool + size::seqno + size::wallet_id + size::public_key)
    .preload_dict();
}